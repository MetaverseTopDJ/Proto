// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NFTServiceClient is the client API for NFTService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NFTServiceClient interface {
	// 盲盒 Metadata
	MysteryBox(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error)
	Note(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error)
	Ticket(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error)
	RemixInfo(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error)
	// 合约
	NftContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error)
	NftContracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractsResponse, error)
	NftContractAddress(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractAddressResponse, error)
	NftContractPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*ContractPaginationResponse, error)
	CreateNftContract(ctx context.Context, in *CreateContractPost, opts ...grpc.CallOption) (*ContractResponse, error)
	UpdateNftContract(ctx context.Context, in *UpdateContractPost, opts ...grpc.CallOption) (*ContractResponse, error)
	ChangeNftContractStatus(ctx context.Context, in *ChangeStatusPost, opts ...grpc.CallOption) (*ContractResponse, error)
	// 合约 辅助功能
	GenUniqueCode(ctx context.Context, in *GenUniqueCodePost, opts ...grpc.CallOption) (*NumberResponse, error)
	GenUniqueCodes(ctx context.Context, in *GenUniqueCodesPost, opts ...grpc.CallOption) (*NumbersResponse, error)
	BlindBoxSignature(ctx context.Context, in *BlindBoxSignPost, opts ...grpc.CallOption) (*SignatureResponse, error)
	RemixSignature(ctx context.Context, in *RemixSignPost, opts ...grpc.CallOption) (*SignatureResponse, error)
	CollectSignature(ctx context.Context, in *CollectSignPost, opts ...grpc.CallOption) (*SignatureResponse, error)
	CheckTransactionByHash(ctx context.Context, in *CheckTransactionByHashPost, opts ...grpc.CallOption) (*ResultResponse, error)
	BlindBoxContracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractsResponse, error)
	StartBlindBoxContract(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ResultResponse, error)
	StopBlindBoxContract(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ResultResponse, error)
	NoteContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error)
	StartNoteContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error)
	StopNoteContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error)
	TicketContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error)
	StartTicketContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error)
	StopTicketContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error)
	// NFT
	// rpc CheckBlindBoxTx (CheckBlindBoxTxPost) returns (global.CheckResponse) {} // 检查盲盒交易
	MemberNftPagination(ctx context.Context, in *MemberNftPaginationPost, opts ...grpc.CallOption) (*MemberNftPaginationResponse, error)
	NftMemberPagination(ctx context.Context, in *NftMemberPaginationPost, opts ...grpc.CallOption) (*NftMemberPaginationResponse, error)
	// NFT 后台
	Nft(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTResponse, error)
	NftPrice(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error)
	CountWorkCollector(ctx context.Context, in *CountWorkCollectorPost, opts ...grpc.CallOption) (*CountResponse, error)
	MemberWorkIDs(ctx context.Context, in *MemberWorkPost, opts ...grpc.CallOption) (*IDsResponse, error)
	MemberCollectWorkIDs(ctx context.Context, in *MemberWorkPost, opts ...grpc.CallOption) (*IDsResponse, error)
	NftPagination(ctx context.Context, in *NftPaginationPost, opts ...grpc.CallOption) (*NFTPaginationResponse, error)
	NftCreatorPagination(ctx context.Context, in *NftCreatorPaginationPost, opts ...grpc.CallOption) (*NFTCreatorPaginationResponse, error)
	NftTransferPagination(ctx context.Context, in *NftTransferPaginationPost, opts ...grpc.CallOption) (*NFTTransferPaginationResponse, error)
	CheckCollectExchangeTx(ctx context.Context, in *CheckCollectExchangePost, opts ...grpc.CallOption) (*CheckResponse, error)
	CheckBlindBoxExchangeTx(ctx context.Context, in *CheckBlindExchangePost, opts ...grpc.CallOption) (*CheckResponse, error)
}

type nFTServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNFTServiceClient(cc grpc.ClientConnInterface) NFTServiceClient {
	return &nFTServiceClient{cc}
}

func (c *nFTServiceClient) MysteryBox(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error) {
	out := new(NFTContentResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/MysteryBox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) Note(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error) {
	out := new(NFTContentResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/Note", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) Ticket(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error) {
	out := new(NFTContentResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/Ticket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) RemixInfo(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTContentResponse, error) {
	out := new(NFTContentResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/RemixInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftContracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractsResponse, error) {
	out := new(ContractsResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftContractAddress(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractAddressResponse, error) {
	out := new(ContractAddressResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftContractAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftContractPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*ContractPaginationResponse, error) {
	out := new(ContractPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftContractPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CreateNftContract(ctx context.Context, in *CreateContractPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CreateNftContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) UpdateNftContract(ctx context.Context, in *UpdateContractPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/UpdateNftContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) ChangeNftContractStatus(ctx context.Context, in *ChangeStatusPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/ChangeNftContractStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) GenUniqueCode(ctx context.Context, in *GenUniqueCodePost, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/GenUniqueCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) GenUniqueCodes(ctx context.Context, in *GenUniqueCodesPost, opts ...grpc.CallOption) (*NumbersResponse, error) {
	out := new(NumbersResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/GenUniqueCodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) BlindBoxSignature(ctx context.Context, in *BlindBoxSignPost, opts ...grpc.CallOption) (*SignatureResponse, error) {
	out := new(SignatureResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/BlindBoxSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) RemixSignature(ctx context.Context, in *RemixSignPost, opts ...grpc.CallOption) (*SignatureResponse, error) {
	out := new(SignatureResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/RemixSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CollectSignature(ctx context.Context, in *CollectSignPost, opts ...grpc.CallOption) (*SignatureResponse, error) {
	out := new(SignatureResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CollectSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CheckTransactionByHash(ctx context.Context, in *CheckTransactionByHashPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CheckTransactionByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) BlindBoxContracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractsResponse, error) {
	out := new(ContractsResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/BlindBoxContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) StartBlindBoxContract(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/StartBlindBoxContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) StopBlindBoxContract(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/StopBlindBoxContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NoteContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NoteContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) StartNoteContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/StartNoteContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) StopNoteContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/StopNoteContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) TicketContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/TicketContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) StartTicketContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/StartTicketContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) StopTicketContract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/StopTicketContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) MemberNftPagination(ctx context.Context, in *MemberNftPaginationPost, opts ...grpc.CallOption) (*MemberNftPaginationResponse, error) {
	out := new(MemberNftPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/MemberNftPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftMemberPagination(ctx context.Context, in *NftMemberPaginationPost, opts ...grpc.CallOption) (*NftMemberPaginationResponse, error) {
	out := new(NftMemberPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftMemberPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) Nft(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTResponse, error) {
	out := new(NFTResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/Nft", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftPrice(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CountWorkCollector(ctx context.Context, in *CountWorkCollectorPost, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CountWorkCollector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) MemberWorkIDs(ctx context.Context, in *MemberWorkPost, opts ...grpc.CallOption) (*IDsResponse, error) {
	out := new(IDsResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/MemberWorkIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) MemberCollectWorkIDs(ctx context.Context, in *MemberWorkPost, opts ...grpc.CallOption) (*IDsResponse, error) {
	out := new(IDsResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/MemberCollectWorkIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftPagination(ctx context.Context, in *NftPaginationPost, opts ...grpc.CallOption) (*NFTPaginationResponse, error) {
	out := new(NFTPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftCreatorPagination(ctx context.Context, in *NftCreatorPaginationPost, opts ...grpc.CallOption) (*NFTCreatorPaginationResponse, error) {
	out := new(NFTCreatorPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftCreatorPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftTransferPagination(ctx context.Context, in *NftTransferPaginationPost, opts ...grpc.CallOption) (*NFTTransferPaginationResponse, error) {
	out := new(NFTTransferPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftTransferPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CheckCollectExchangeTx(ctx context.Context, in *CheckCollectExchangePost, opts ...grpc.CallOption) (*CheckResponse, error) {
	out := new(CheckResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CheckCollectExchangeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CheckBlindBoxExchangeTx(ctx context.Context, in *CheckBlindExchangePost, opts ...grpc.CallOption) (*CheckResponse, error) {
	out := new(CheckResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CheckBlindBoxExchangeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NFTServiceServer is the server API for NFTService service.
// All implementations must embed UnimplementedNFTServiceServer
// for forward compatibility
type NFTServiceServer interface {
	// 盲盒 Metadata
	MysteryBox(context.Context, *InfoPost) (*NFTContentResponse, error)
	Note(context.Context, *InfoPost) (*NFTContentResponse, error)
	Ticket(context.Context, *InfoPost) (*NFTContentResponse, error)
	RemixInfo(context.Context, *InfoPost) (*NFTContentResponse, error)
	// 合约
	NftContract(context.Context, *InfoPost) (*ContractResponse, error)
	NftContracts(context.Context, *EmptyPost) (*ContractsResponse, error)
	NftContractAddress(context.Context, *EmptyPost) (*ContractAddressResponse, error)
	NftContractPagination(context.Context, *PaginationPost) (*ContractPaginationResponse, error)
	CreateNftContract(context.Context, *CreateContractPost) (*ContractResponse, error)
	UpdateNftContract(context.Context, *UpdateContractPost) (*ContractResponse, error)
	ChangeNftContractStatus(context.Context, *ChangeStatusPost) (*ContractResponse, error)
	// 合约 辅助功能
	GenUniqueCode(context.Context, *GenUniqueCodePost) (*NumberResponse, error)
	GenUniqueCodes(context.Context, *GenUniqueCodesPost) (*NumbersResponse, error)
	BlindBoxSignature(context.Context, *BlindBoxSignPost) (*SignatureResponse, error)
	RemixSignature(context.Context, *RemixSignPost) (*SignatureResponse, error)
	CollectSignature(context.Context, *CollectSignPost) (*SignatureResponse, error)
	CheckTransactionByHash(context.Context, *CheckTransactionByHashPost) (*ResultResponse, error)
	BlindBoxContracts(context.Context, *EmptyPost) (*ContractsResponse, error)
	StartBlindBoxContract(context.Context, *EmptyPost) (*ResultResponse, error)
	StopBlindBoxContract(context.Context, *EmptyPost) (*ResultResponse, error)
	NoteContract(context.Context, *InfoPost) (*ContractResponse, error)
	StartNoteContract(context.Context, *InfoPost) (*ResultResponse, error)
	StopNoteContract(context.Context, *InfoPost) (*ResultResponse, error)
	TicketContract(context.Context, *InfoPost) (*ContractResponse, error)
	StartTicketContract(context.Context, *InfoPost) (*ResultResponse, error)
	StopTicketContract(context.Context, *InfoPost) (*ResultResponse, error)
	// NFT
	// rpc CheckBlindBoxTx (CheckBlindBoxTxPost) returns (global.CheckResponse) {} // 检查盲盒交易
	MemberNftPagination(context.Context, *MemberNftPaginationPost) (*MemberNftPaginationResponse, error)
	NftMemberPagination(context.Context, *NftMemberPaginationPost) (*NftMemberPaginationResponse, error)
	// NFT 后台
	Nft(context.Context, *InfoPost) (*NFTResponse, error)
	NftPrice(context.Context, *InfoPost) (*ResultResponse, error)
	CountWorkCollector(context.Context, *CountWorkCollectorPost) (*CountResponse, error)
	MemberWorkIDs(context.Context, *MemberWorkPost) (*IDsResponse, error)
	MemberCollectWorkIDs(context.Context, *MemberWorkPost) (*IDsResponse, error)
	NftPagination(context.Context, *NftPaginationPost) (*NFTPaginationResponse, error)
	NftCreatorPagination(context.Context, *NftCreatorPaginationPost) (*NFTCreatorPaginationResponse, error)
	NftTransferPagination(context.Context, *NftTransferPaginationPost) (*NFTTransferPaginationResponse, error)
	CheckCollectExchangeTx(context.Context, *CheckCollectExchangePost) (*CheckResponse, error)
	CheckBlindBoxExchangeTx(context.Context, *CheckBlindExchangePost) (*CheckResponse, error)
	mustEmbedUnimplementedNFTServiceServer()
}

// UnimplementedNFTServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNFTServiceServer struct {
}

func (UnimplementedNFTServiceServer) MysteryBox(context.Context, *InfoPost) (*NFTContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MysteryBox not implemented")
}
func (UnimplementedNFTServiceServer) Note(context.Context, *InfoPost) (*NFTContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Note not implemented")
}
func (UnimplementedNFTServiceServer) Ticket(context.Context, *InfoPost) (*NFTContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ticket not implemented")
}
func (UnimplementedNFTServiceServer) RemixInfo(context.Context, *InfoPost) (*NFTContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemixInfo not implemented")
}
func (UnimplementedNFTServiceServer) NftContract(context.Context, *InfoPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftContract not implemented")
}
func (UnimplementedNFTServiceServer) NftContracts(context.Context, *EmptyPost) (*ContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftContracts not implemented")
}
func (UnimplementedNFTServiceServer) NftContractAddress(context.Context, *EmptyPost) (*ContractAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftContractAddress not implemented")
}
func (UnimplementedNFTServiceServer) NftContractPagination(context.Context, *PaginationPost) (*ContractPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftContractPagination not implemented")
}
func (UnimplementedNFTServiceServer) CreateNftContract(context.Context, *CreateContractPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNftContract not implemented")
}
func (UnimplementedNFTServiceServer) UpdateNftContract(context.Context, *UpdateContractPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNftContract not implemented")
}
func (UnimplementedNFTServiceServer) ChangeNftContractStatus(context.Context, *ChangeStatusPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeNftContractStatus not implemented")
}
func (UnimplementedNFTServiceServer) GenUniqueCode(context.Context, *GenUniqueCodePost) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenUniqueCode not implemented")
}
func (UnimplementedNFTServiceServer) GenUniqueCodes(context.Context, *GenUniqueCodesPost) (*NumbersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenUniqueCodes not implemented")
}
func (UnimplementedNFTServiceServer) BlindBoxSignature(context.Context, *BlindBoxSignPost) (*SignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlindBoxSignature not implemented")
}
func (UnimplementedNFTServiceServer) RemixSignature(context.Context, *RemixSignPost) (*SignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemixSignature not implemented")
}
func (UnimplementedNFTServiceServer) CollectSignature(context.Context, *CollectSignPost) (*SignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectSignature not implemented")
}
func (UnimplementedNFTServiceServer) CheckTransactionByHash(context.Context, *CheckTransactionByHashPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckTransactionByHash not implemented")
}
func (UnimplementedNFTServiceServer) BlindBoxContracts(context.Context, *EmptyPost) (*ContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlindBoxContracts not implemented")
}
func (UnimplementedNFTServiceServer) StartBlindBoxContract(context.Context, *EmptyPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBlindBoxContract not implemented")
}
func (UnimplementedNFTServiceServer) StopBlindBoxContract(context.Context, *EmptyPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopBlindBoxContract not implemented")
}
func (UnimplementedNFTServiceServer) NoteContract(context.Context, *InfoPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoteContract not implemented")
}
func (UnimplementedNFTServiceServer) StartNoteContract(context.Context, *InfoPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartNoteContract not implemented")
}
func (UnimplementedNFTServiceServer) StopNoteContract(context.Context, *InfoPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopNoteContract not implemented")
}
func (UnimplementedNFTServiceServer) TicketContract(context.Context, *InfoPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TicketContract not implemented")
}
func (UnimplementedNFTServiceServer) StartTicketContract(context.Context, *InfoPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTicketContract not implemented")
}
func (UnimplementedNFTServiceServer) StopTicketContract(context.Context, *InfoPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTicketContract not implemented")
}
func (UnimplementedNFTServiceServer) MemberNftPagination(context.Context, *MemberNftPaginationPost) (*MemberNftPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberNftPagination not implemented")
}
func (UnimplementedNFTServiceServer) NftMemberPagination(context.Context, *NftMemberPaginationPost) (*NftMemberPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftMemberPagination not implemented")
}
func (UnimplementedNFTServiceServer) Nft(context.Context, *InfoPost) (*NFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Nft not implemented")
}
func (UnimplementedNFTServiceServer) NftPrice(context.Context, *InfoPost) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftPrice not implemented")
}
func (UnimplementedNFTServiceServer) CountWorkCollector(context.Context, *CountWorkCollectorPost) (*CountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountWorkCollector not implemented")
}
func (UnimplementedNFTServiceServer) MemberWorkIDs(context.Context, *MemberWorkPost) (*IDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberWorkIDs not implemented")
}
func (UnimplementedNFTServiceServer) MemberCollectWorkIDs(context.Context, *MemberWorkPost) (*IDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberCollectWorkIDs not implemented")
}
func (UnimplementedNFTServiceServer) NftPagination(context.Context, *NftPaginationPost) (*NFTPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftPagination not implemented")
}
func (UnimplementedNFTServiceServer) NftCreatorPagination(context.Context, *NftCreatorPaginationPost) (*NFTCreatorPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftCreatorPagination not implemented")
}
func (UnimplementedNFTServiceServer) NftTransferPagination(context.Context, *NftTransferPaginationPost) (*NFTTransferPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftTransferPagination not implemented")
}
func (UnimplementedNFTServiceServer) CheckCollectExchangeTx(context.Context, *CheckCollectExchangePost) (*CheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckCollectExchangeTx not implemented")
}
func (UnimplementedNFTServiceServer) CheckBlindBoxExchangeTx(context.Context, *CheckBlindExchangePost) (*CheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckBlindBoxExchangeTx not implemented")
}
func (UnimplementedNFTServiceServer) mustEmbedUnimplementedNFTServiceServer() {}

// UnsafeNFTServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NFTServiceServer will
// result in compilation errors.
type UnsafeNFTServiceServer interface {
	mustEmbedUnimplementedNFTServiceServer()
}

func RegisterNFTServiceServer(s grpc.ServiceRegistrar, srv NFTServiceServer) {
	s.RegisterService(&NFTService_ServiceDesc, srv)
}

func _NFTService_MysteryBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).MysteryBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/MysteryBox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).MysteryBox(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_Note_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).Note(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/Note",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).Note(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_Ticket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).Ticket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/Ticket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).Ticket(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_RemixInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).RemixInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/RemixInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).RemixInfo(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftContracts(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftContractAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftContractAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftContractAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftContractAddress(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftContractPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftContractPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftContractPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftContractPagination(ctx, req.(*PaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CreateNftContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContractPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CreateNftContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CreateNftContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CreateNftContract(ctx, req.(*CreateContractPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_UpdateNftContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContractPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).UpdateNftContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/UpdateNftContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).UpdateNftContract(ctx, req.(*UpdateContractPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_ChangeNftContractStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeStatusPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).ChangeNftContractStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/ChangeNftContractStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).ChangeNftContractStatus(ctx, req.(*ChangeStatusPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_GenUniqueCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenUniqueCodePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).GenUniqueCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/GenUniqueCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).GenUniqueCode(ctx, req.(*GenUniqueCodePost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_GenUniqueCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenUniqueCodesPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).GenUniqueCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/GenUniqueCodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).GenUniqueCodes(ctx, req.(*GenUniqueCodesPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_BlindBoxSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlindBoxSignPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).BlindBoxSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/BlindBoxSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).BlindBoxSignature(ctx, req.(*BlindBoxSignPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_RemixSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemixSignPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).RemixSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/RemixSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).RemixSignature(ctx, req.(*RemixSignPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CollectSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectSignPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CollectSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CollectSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CollectSignature(ctx, req.(*CollectSignPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CheckTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckTransactionByHashPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CheckTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CheckTransactionByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CheckTransactionByHash(ctx, req.(*CheckTransactionByHashPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_BlindBoxContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).BlindBoxContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/BlindBoxContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).BlindBoxContracts(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_StartBlindBoxContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).StartBlindBoxContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/StartBlindBoxContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).StartBlindBoxContract(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_StopBlindBoxContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).StopBlindBoxContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/StopBlindBoxContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).StopBlindBoxContract(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NoteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NoteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NoteContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NoteContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_StartNoteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).StartNoteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/StartNoteContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).StartNoteContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_StopNoteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).StopNoteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/StopNoteContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).StopNoteContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_TicketContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).TicketContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/TicketContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).TicketContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_StartTicketContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).StartTicketContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/StartTicketContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).StartTicketContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_StopTicketContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).StopTicketContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/StopTicketContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).StopTicketContract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_MemberNftPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberNftPaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).MemberNftPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/MemberNftPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).MemberNftPagination(ctx, req.(*MemberNftPaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftMemberPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NftMemberPaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftMemberPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftMemberPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftMemberPagination(ctx, req.(*NftMemberPaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_Nft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).Nft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/Nft",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).Nft(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftPrice(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CountWorkCollector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountWorkCollectorPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CountWorkCollector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CountWorkCollector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CountWorkCollector(ctx, req.(*CountWorkCollectorPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_MemberWorkIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberWorkPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).MemberWorkIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/MemberWorkIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).MemberWorkIDs(ctx, req.(*MemberWorkPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_MemberCollectWorkIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberWorkPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).MemberCollectWorkIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/MemberCollectWorkIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).MemberCollectWorkIDs(ctx, req.(*MemberWorkPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NftPaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftPagination(ctx, req.(*NftPaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftCreatorPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NftCreatorPaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftCreatorPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftCreatorPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftCreatorPagination(ctx, req.(*NftCreatorPaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftTransferPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NftTransferPaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftTransferPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftTransferPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftTransferPagination(ctx, req.(*NftTransferPaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CheckCollectExchangeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCollectExchangePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CheckCollectExchangeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CheckCollectExchangeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CheckCollectExchangeTx(ctx, req.(*CheckCollectExchangePost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CheckBlindBoxExchangeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBlindExchangePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CheckBlindBoxExchangeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CheckBlindBoxExchangeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CheckBlindBoxExchangeTx(ctx, req.(*CheckBlindExchangePost))
	}
	return interceptor(ctx, in, info, handler)
}

// NFTService_ServiceDesc is the grpc.ServiceDesc for NFTService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NFTService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nft.NFTService",
	HandlerType: (*NFTServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MysteryBox",
			Handler:    _NFTService_MysteryBox_Handler,
		},
		{
			MethodName: "Note",
			Handler:    _NFTService_Note_Handler,
		},
		{
			MethodName: "Ticket",
			Handler:    _NFTService_Ticket_Handler,
		},
		{
			MethodName: "RemixInfo",
			Handler:    _NFTService_RemixInfo_Handler,
		},
		{
			MethodName: "NftContract",
			Handler:    _NFTService_NftContract_Handler,
		},
		{
			MethodName: "NftContracts",
			Handler:    _NFTService_NftContracts_Handler,
		},
		{
			MethodName: "NftContractAddress",
			Handler:    _NFTService_NftContractAddress_Handler,
		},
		{
			MethodName: "NftContractPagination",
			Handler:    _NFTService_NftContractPagination_Handler,
		},
		{
			MethodName: "CreateNftContract",
			Handler:    _NFTService_CreateNftContract_Handler,
		},
		{
			MethodName: "UpdateNftContract",
			Handler:    _NFTService_UpdateNftContract_Handler,
		},
		{
			MethodName: "ChangeNftContractStatus",
			Handler:    _NFTService_ChangeNftContractStatus_Handler,
		},
		{
			MethodName: "GenUniqueCode",
			Handler:    _NFTService_GenUniqueCode_Handler,
		},
		{
			MethodName: "GenUniqueCodes",
			Handler:    _NFTService_GenUniqueCodes_Handler,
		},
		{
			MethodName: "BlindBoxSignature",
			Handler:    _NFTService_BlindBoxSignature_Handler,
		},
		{
			MethodName: "RemixSignature",
			Handler:    _NFTService_RemixSignature_Handler,
		},
		{
			MethodName: "CollectSignature",
			Handler:    _NFTService_CollectSignature_Handler,
		},
		{
			MethodName: "CheckTransactionByHash",
			Handler:    _NFTService_CheckTransactionByHash_Handler,
		},
		{
			MethodName: "BlindBoxContracts",
			Handler:    _NFTService_BlindBoxContracts_Handler,
		},
		{
			MethodName: "StartBlindBoxContract",
			Handler:    _NFTService_StartBlindBoxContract_Handler,
		},
		{
			MethodName: "StopBlindBoxContract",
			Handler:    _NFTService_StopBlindBoxContract_Handler,
		},
		{
			MethodName: "NoteContract",
			Handler:    _NFTService_NoteContract_Handler,
		},
		{
			MethodName: "StartNoteContract",
			Handler:    _NFTService_StartNoteContract_Handler,
		},
		{
			MethodName: "StopNoteContract",
			Handler:    _NFTService_StopNoteContract_Handler,
		},
		{
			MethodName: "TicketContract",
			Handler:    _NFTService_TicketContract_Handler,
		},
		{
			MethodName: "StartTicketContract",
			Handler:    _NFTService_StartTicketContract_Handler,
		},
		{
			MethodName: "StopTicketContract",
			Handler:    _NFTService_StopTicketContract_Handler,
		},
		{
			MethodName: "MemberNftPagination",
			Handler:    _NFTService_MemberNftPagination_Handler,
		},
		{
			MethodName: "NftMemberPagination",
			Handler:    _NFTService_NftMemberPagination_Handler,
		},
		{
			MethodName: "Nft",
			Handler:    _NFTService_Nft_Handler,
		},
		{
			MethodName: "NftPrice",
			Handler:    _NFTService_NftPrice_Handler,
		},
		{
			MethodName: "CountWorkCollector",
			Handler:    _NFTService_CountWorkCollector_Handler,
		},
		{
			MethodName: "MemberWorkIDs",
			Handler:    _NFTService_MemberWorkIDs_Handler,
		},
		{
			MethodName: "MemberCollectWorkIDs",
			Handler:    _NFTService_MemberCollectWorkIDs_Handler,
		},
		{
			MethodName: "NftPagination",
			Handler:    _NFTService_NftPagination_Handler,
		},
		{
			MethodName: "NftCreatorPagination",
			Handler:    _NFTService_NftCreatorPagination_Handler,
		},
		{
			MethodName: "NftTransferPagination",
			Handler:    _NFTService_NftTransferPagination_Handler,
		},
		{
			MethodName: "CheckCollectExchangeTx",
			Handler:    _NFTService_CheckCollectExchangeTx_Handler,
		},
		{
			MethodName: "CheckBlindBoxExchangeTx",
			Handler:    _NFTService_CheckBlindBoxExchangeTx_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nft/nft.proto",
}
