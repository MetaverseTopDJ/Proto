// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NFTServiceClient is the client API for NFTService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NFTServiceClient interface {
	// Token 通证
	NftToken(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTTokenResponse, error)
	NftTokenPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*NFTTokenPaginationResponse, error)
	CreateNftToken(ctx context.Context, in *CreateNFTTokenPost, opts ...grpc.CallOption) (*NFTTokenResponse, error)
	UpdateNftToken(ctx context.Context, in *UpdateNFTTokenPost, opts ...grpc.CallOption) (*NFTTokenResponse, error)
	ChangeNftTokenStatus(ctx context.Context, in *ChangeStatusPost, opts ...grpc.CallOption) (*NFTTokenResponse, error)
	// Contract 智能合约
	Contract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error)
	MemberContractAddress(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractAddressResponse, error)
	WorkContractAddress(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractAddressResponse, error)
	Contracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractsResponse, error)
	ContractPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*ContractPaginationResponse, error)
	CreateContract(ctx context.Context, in *CreateContractPost, opts ...grpc.CallOption) (*ContractResponse, error)
	UpdateContract(ctx context.Context, in *UpdateContractPost, opts ...grpc.CallOption) (*ContractResponse, error)
	ChangeContractStatus(ctx context.Context, in *ChangeStatusPost, opts ...grpc.CallOption) (*ContractResponse, error)
	// BlockCrontab 区块扫描 计划任务
	BlockCrontab(ctx context.Context, in *InfoCodePost, opts ...grpc.CallOption) (*BlockCrontabResponse, error)
	BlockContracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*BlockCrontabsResponse, error)
	BlockCrontabPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*BlockCrontabPaginationResponse, error)
	CreateBlockCrontab(ctx context.Context, in *ModifyBlockCrontabPost, opts ...grpc.CallOption) (*BlockCrontabResponse, error)
	UpdateBlockCrontab(ctx context.Context, in *ModifyBlockCrontabPost, opts ...grpc.CallOption) (*BlockCrontabResponse, error)
	ChangeBlockCrontabStatus(ctx context.Context, in *ChangeStatusByCodePost, opts ...grpc.CallOption) (*BlockCrontabResponse, error)
}

type nFTServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNFTServiceClient(cc grpc.ClientConnInterface) NFTServiceClient {
	return &nFTServiceClient{cc}
}

func (c *nFTServiceClient) NftToken(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*NFTTokenResponse, error) {
	out := new(NFTTokenResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) NftTokenPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*NFTTokenPaginationResponse, error) {
	out := new(NFTTokenPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/NftTokenPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CreateNftToken(ctx context.Context, in *CreateNFTTokenPost, opts ...grpc.CallOption) (*NFTTokenResponse, error) {
	out := new(NFTTokenResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CreateNftToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) UpdateNftToken(ctx context.Context, in *UpdateNFTTokenPost, opts ...grpc.CallOption) (*NFTTokenResponse, error) {
	out := new(NFTTokenResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/UpdateNftToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) ChangeNftTokenStatus(ctx context.Context, in *ChangeStatusPost, opts ...grpc.CallOption) (*NFTTokenResponse, error) {
	out := new(NFTTokenResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/ChangeNftTokenStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) Contract(ctx context.Context, in *InfoPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/Contract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) MemberContractAddress(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractAddressResponse, error) {
	out := new(ContractAddressResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/MemberContractAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) WorkContractAddress(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractAddressResponse, error) {
	out := new(ContractAddressResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/WorkContractAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) Contracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*ContractsResponse, error) {
	out := new(ContractsResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/Contracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) ContractPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*ContractPaginationResponse, error) {
	out := new(ContractPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/ContractPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CreateContract(ctx context.Context, in *CreateContractPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CreateContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) UpdateContract(ctx context.Context, in *UpdateContractPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/UpdateContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) ChangeContractStatus(ctx context.Context, in *ChangeStatusPost, opts ...grpc.CallOption) (*ContractResponse, error) {
	out := new(ContractResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/ChangeContractStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) BlockCrontab(ctx context.Context, in *InfoCodePost, opts ...grpc.CallOption) (*BlockCrontabResponse, error) {
	out := new(BlockCrontabResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/BlockCrontab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) BlockContracts(ctx context.Context, in *EmptyPost, opts ...grpc.CallOption) (*BlockCrontabsResponse, error) {
	out := new(BlockCrontabsResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/BlockContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) BlockCrontabPagination(ctx context.Context, in *PaginationPost, opts ...grpc.CallOption) (*BlockCrontabPaginationResponse, error) {
	out := new(BlockCrontabPaginationResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/BlockCrontabPagination", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) CreateBlockCrontab(ctx context.Context, in *ModifyBlockCrontabPost, opts ...grpc.CallOption) (*BlockCrontabResponse, error) {
	out := new(BlockCrontabResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/CreateBlockCrontab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) UpdateBlockCrontab(ctx context.Context, in *ModifyBlockCrontabPost, opts ...grpc.CallOption) (*BlockCrontabResponse, error) {
	out := new(BlockCrontabResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/UpdateBlockCrontab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nFTServiceClient) ChangeBlockCrontabStatus(ctx context.Context, in *ChangeStatusByCodePost, opts ...grpc.CallOption) (*BlockCrontabResponse, error) {
	out := new(BlockCrontabResponse)
	err := c.cc.Invoke(ctx, "/nft.NFTService/ChangeBlockCrontabStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NFTServiceServer is the server API for NFTService service.
// All implementations must embed UnimplementedNFTServiceServer
// for forward compatibility
type NFTServiceServer interface {
	// Token 通证
	NftToken(context.Context, *InfoPost) (*NFTTokenResponse, error)
	NftTokenPagination(context.Context, *PaginationPost) (*NFTTokenPaginationResponse, error)
	CreateNftToken(context.Context, *CreateNFTTokenPost) (*NFTTokenResponse, error)
	UpdateNftToken(context.Context, *UpdateNFTTokenPost) (*NFTTokenResponse, error)
	ChangeNftTokenStatus(context.Context, *ChangeStatusPost) (*NFTTokenResponse, error)
	// Contract 智能合约
	Contract(context.Context, *InfoPost) (*ContractResponse, error)
	MemberContractAddress(context.Context, *EmptyPost) (*ContractAddressResponse, error)
	WorkContractAddress(context.Context, *EmptyPost) (*ContractAddressResponse, error)
	Contracts(context.Context, *EmptyPost) (*ContractsResponse, error)
	ContractPagination(context.Context, *PaginationPost) (*ContractPaginationResponse, error)
	CreateContract(context.Context, *CreateContractPost) (*ContractResponse, error)
	UpdateContract(context.Context, *UpdateContractPost) (*ContractResponse, error)
	ChangeContractStatus(context.Context, *ChangeStatusPost) (*ContractResponse, error)
	// BlockCrontab 区块扫描 计划任务
	BlockCrontab(context.Context, *InfoCodePost) (*BlockCrontabResponse, error)
	BlockContracts(context.Context, *EmptyPost) (*BlockCrontabsResponse, error)
	BlockCrontabPagination(context.Context, *PaginationPost) (*BlockCrontabPaginationResponse, error)
	CreateBlockCrontab(context.Context, *ModifyBlockCrontabPost) (*BlockCrontabResponse, error)
	UpdateBlockCrontab(context.Context, *ModifyBlockCrontabPost) (*BlockCrontabResponse, error)
	ChangeBlockCrontabStatus(context.Context, *ChangeStatusByCodePost) (*BlockCrontabResponse, error)
	mustEmbedUnimplementedNFTServiceServer()
}

// UnimplementedNFTServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNFTServiceServer struct {
}

func (UnimplementedNFTServiceServer) NftToken(context.Context, *InfoPost) (*NFTTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftToken not implemented")
}
func (UnimplementedNFTServiceServer) NftTokenPagination(context.Context, *PaginationPost) (*NFTTokenPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NftTokenPagination not implemented")
}
func (UnimplementedNFTServiceServer) CreateNftToken(context.Context, *CreateNFTTokenPost) (*NFTTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNftToken not implemented")
}
func (UnimplementedNFTServiceServer) UpdateNftToken(context.Context, *UpdateNFTTokenPost) (*NFTTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNftToken not implemented")
}
func (UnimplementedNFTServiceServer) ChangeNftTokenStatus(context.Context, *ChangeStatusPost) (*NFTTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeNftTokenStatus not implemented")
}
func (UnimplementedNFTServiceServer) Contract(context.Context, *InfoPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Contract not implemented")
}
func (UnimplementedNFTServiceServer) MemberContractAddress(context.Context, *EmptyPost) (*ContractAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberContractAddress not implemented")
}
func (UnimplementedNFTServiceServer) WorkContractAddress(context.Context, *EmptyPost) (*ContractAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkContractAddress not implemented")
}
func (UnimplementedNFTServiceServer) Contracts(context.Context, *EmptyPost) (*ContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Contracts not implemented")
}
func (UnimplementedNFTServiceServer) ContractPagination(context.Context, *PaginationPost) (*ContractPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractPagination not implemented")
}
func (UnimplementedNFTServiceServer) CreateContract(context.Context, *CreateContractPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContract not implemented")
}
func (UnimplementedNFTServiceServer) UpdateContract(context.Context, *UpdateContractPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateContract not implemented")
}
func (UnimplementedNFTServiceServer) ChangeContractStatus(context.Context, *ChangeStatusPost) (*ContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeContractStatus not implemented")
}
func (UnimplementedNFTServiceServer) BlockCrontab(context.Context, *InfoCodePost) (*BlockCrontabResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockCrontab not implemented")
}
func (UnimplementedNFTServiceServer) BlockContracts(context.Context, *EmptyPost) (*BlockCrontabsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockContracts not implemented")
}
func (UnimplementedNFTServiceServer) BlockCrontabPagination(context.Context, *PaginationPost) (*BlockCrontabPaginationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockCrontabPagination not implemented")
}
func (UnimplementedNFTServiceServer) CreateBlockCrontab(context.Context, *ModifyBlockCrontabPost) (*BlockCrontabResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBlockCrontab not implemented")
}
func (UnimplementedNFTServiceServer) UpdateBlockCrontab(context.Context, *ModifyBlockCrontabPost) (*BlockCrontabResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBlockCrontab not implemented")
}
func (UnimplementedNFTServiceServer) ChangeBlockCrontabStatus(context.Context, *ChangeStatusByCodePost) (*BlockCrontabResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeBlockCrontabStatus not implemented")
}
func (UnimplementedNFTServiceServer) mustEmbedUnimplementedNFTServiceServer() {}

// UnsafeNFTServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NFTServiceServer will
// result in compilation errors.
type UnsafeNFTServiceServer interface {
	mustEmbedUnimplementedNFTServiceServer()
}

func RegisterNFTServiceServer(s grpc.ServiceRegistrar, srv NFTServiceServer) {
	s.RegisterService(&NFTService_ServiceDesc, srv)
}

func _NFTService_NftToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftToken(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_NftTokenPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).NftTokenPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/NftTokenPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).NftTokenPagination(ctx, req.(*PaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CreateNftToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNFTTokenPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CreateNftToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CreateNftToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CreateNftToken(ctx, req.(*CreateNFTTokenPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_UpdateNftToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNFTTokenPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).UpdateNftToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/UpdateNftToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).UpdateNftToken(ctx, req.(*UpdateNFTTokenPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_ChangeNftTokenStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeStatusPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).ChangeNftTokenStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/ChangeNftTokenStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).ChangeNftTokenStatus(ctx, req.(*ChangeStatusPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_Contract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).Contract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/Contract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).Contract(ctx, req.(*InfoPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_MemberContractAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).MemberContractAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/MemberContractAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).MemberContractAddress(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_WorkContractAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).WorkContractAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/WorkContractAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).WorkContractAddress(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_Contracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).Contracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/Contracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).Contracts(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_ContractPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).ContractPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/ContractPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).ContractPagination(ctx, req.(*PaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CreateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContractPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CreateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CreateContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CreateContract(ctx, req.(*CreateContractPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_UpdateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContractPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).UpdateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/UpdateContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).UpdateContract(ctx, req.(*UpdateContractPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_ChangeContractStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeStatusPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).ChangeContractStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/ChangeContractStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).ChangeContractStatus(ctx, req.(*ChangeStatusPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_BlockCrontab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoCodePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).BlockCrontab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/BlockCrontab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).BlockCrontab(ctx, req.(*InfoCodePost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_BlockContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).BlockContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/BlockContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).BlockContracts(ctx, req.(*EmptyPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_BlockCrontabPagination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaginationPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).BlockCrontabPagination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/BlockCrontabPagination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).BlockCrontabPagination(ctx, req.(*PaginationPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_CreateBlockCrontab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyBlockCrontabPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).CreateBlockCrontab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/CreateBlockCrontab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).CreateBlockCrontab(ctx, req.(*ModifyBlockCrontabPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_UpdateBlockCrontab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyBlockCrontabPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).UpdateBlockCrontab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/UpdateBlockCrontab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).UpdateBlockCrontab(ctx, req.(*ModifyBlockCrontabPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _NFTService_ChangeBlockCrontabStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeStatusByCodePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NFTServiceServer).ChangeBlockCrontabStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nft.NFTService/ChangeBlockCrontabStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NFTServiceServer).ChangeBlockCrontabStatus(ctx, req.(*ChangeStatusByCodePost))
	}
	return interceptor(ctx, in, info, handler)
}

// NFTService_ServiceDesc is the grpc.ServiceDesc for NFTService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NFTService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nft.NFTService",
	HandlerType: (*NFTServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NftToken",
			Handler:    _NFTService_NftToken_Handler,
		},
		{
			MethodName: "NftTokenPagination",
			Handler:    _NFTService_NftTokenPagination_Handler,
		},
		{
			MethodName: "CreateNftToken",
			Handler:    _NFTService_CreateNftToken_Handler,
		},
		{
			MethodName: "UpdateNftToken",
			Handler:    _NFTService_UpdateNftToken_Handler,
		},
		{
			MethodName: "ChangeNftTokenStatus",
			Handler:    _NFTService_ChangeNftTokenStatus_Handler,
		},
		{
			MethodName: "Contract",
			Handler:    _NFTService_Contract_Handler,
		},
		{
			MethodName: "MemberContractAddress",
			Handler:    _NFTService_MemberContractAddress_Handler,
		},
		{
			MethodName: "WorkContractAddress",
			Handler:    _NFTService_WorkContractAddress_Handler,
		},
		{
			MethodName: "Contracts",
			Handler:    _NFTService_Contracts_Handler,
		},
		{
			MethodName: "ContractPagination",
			Handler:    _NFTService_ContractPagination_Handler,
		},
		{
			MethodName: "CreateContract",
			Handler:    _NFTService_CreateContract_Handler,
		},
		{
			MethodName: "UpdateContract",
			Handler:    _NFTService_UpdateContract_Handler,
		},
		{
			MethodName: "ChangeContractStatus",
			Handler:    _NFTService_ChangeContractStatus_Handler,
		},
		{
			MethodName: "BlockCrontab",
			Handler:    _NFTService_BlockCrontab_Handler,
		},
		{
			MethodName: "BlockContracts",
			Handler:    _NFTService_BlockContracts_Handler,
		},
		{
			MethodName: "BlockCrontabPagination",
			Handler:    _NFTService_BlockCrontabPagination_Handler,
		},
		{
			MethodName: "CreateBlockCrontab",
			Handler:    _NFTService_CreateBlockCrontab_Handler,
		},
		{
			MethodName: "UpdateBlockCrontab",
			Handler:    _NFTService_UpdateBlockCrontab_Handler,
		},
		{
			MethodName: "ChangeBlockCrontabStatus",
			Handler:    _NFTService_ChangeBlockCrontabStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nft/nft.proto",
}
